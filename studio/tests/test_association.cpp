

#include "os_util.h"
#include "hdlc.h"
#include "csm_array.h"
#include "csm_association.h"

#include "catch.hpp"
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdint>


static const uint8_t expected_aarq[] = {  0x60U,  0x36U, 0xA1U,   0x09U,   0x06U,   0x07U,  0x60U,  0x85U,
                                        0x74U,   0x05U,   0x08U,   0x01U,   0x01U, 0x8AU,   0x02U,   0x07U,
                                        0x80U, 0x8BU,   0x07U,  0x60U,  0x85U,  0x74U,   0x05U,   0x08U,
                                         0x02U,   0x01U, 0xACU, 0x0AU,  0x80U,   0x08U,  0x00U,  0x00U,
                                        0x00U,  0x00U,  0x00U,  0x00U,  0x00U,  0x00U, 0xBEU,  0x10U,
                                         0x04U, 0x0EU,   0x01U,   0x00U,   0x00U,   0x00U,   0x06U, 0x5FU,
                                       0x1FU,   0x04U,   0x00U,   0xFFU,  0xFFU, 0xFFU, 0xFFU, 0xFFU
 };

// Two AARQ examples, first one generated by us, second is by Gurux stack
// 60 36 A1 09060760857405080101 8A020780 8B0760857405080201AC0A8008 0000000000000000 BE10040E 01 00 00 00 065F1F0400 FFFFFF FFFF
// 60 36 A1 09060760857405080101 8A020780 8B0760857405080201AC0A8008 4142434445464748 BE10040E 01 00 00 00 065F1F0400 401E1D FFFF

extern "C" void csm_sys_init();

void AARQEncoder()
{
    csm_asso_state state;
    static const uint32_t packet_size = 150U;
    uint8_t packet[packet_size];
    csm_array array;

    csm_sys_init();

    state.auth_level = CSM_AUTH_LOW_LEVEL;
    state.ref = LN_REF;

    csm_array_init(&array, &packet[0], packet_size, 0U, 0U);

    int ret = csm_asso_encoder(&state, &array, CSM_ASSO_AARQ);

    REQUIRE(ret == TRUE);

    debug_puts("AARQ data: ");
    print_hex((const char*)&packet[0], csm_array_written(&array));
    debug_puts("\r\n");

    for (uint32_t i = 0; i< sizeof(expected_aarq); i++)
    {
        if (expected_aarq[i] != packet[i])
        {
            std::cout << "Different at: " << i << std::endl;
        }
        REQUIRE(expected_aarq[i] == packet[i]);
    }
}

uint8_t *HexToBin(const char *input, uint32_t size)
{
    size_t packet_size = size/2U;
    uint8_t *packet = (uint8_t *) malloc(packet_size);

    if (packet != NULL)
    {
        int ret;
        uint8_t *packet_ptr = packet;

        hex2bin(input, (char *)packet, size);
    }

    return packet;
}


static const char aarq_saphir_enerdis[] = "6037A1090607608574050801018A0207808B0760857405080202AC0A80086E2A3834582A202FBE11040F0100010100065F1F040000BE1D0400";
static const char aare_saphir_enerdis[] = "6164A109060760857405080101A203020100A305A10302010E88020780890760857405080202AA2C802A0B2EF7388ACE48BB9A2B4866047058594E3004F6F31AED93A08740138E7F1C98AD15CF38E210EA7D3A34BE10040E0800065F1F040000381D04000007";


static const char aare_hls_ok[] = "614FA109060760857405080101A203020100A305A10302010EA40A0408414243444546474888020780890760857405080205AA0A8008503677524A323146BE11040F080100065F1F040000021D04000007";

static const char aare_no_auth_ok[] = "6182003A80020780A109060760857405080101A203020100A305A10302010088020780890760857405080201BE10040E0800065F1F040000301D21340007";

static const char aare_auth_ok_simple[] = "6129A109060760857405080101A203020100A305A103020100BE10040E0800065F1F040000181D02000007";


static const char aare_saphir_ko[] = "6142A109060760857405080101A203020101A305A10302010B88020780890760857405080202AA0A80088089076085740508BE10040E0800065F1F040000381D04000007";

// FIXME: decode AARE 6182001B80020780A109060760857405080101A203020101A305A10302010B
// (in case of auth level not supported, should be a valid frame)
/*
<AssociationResponse>
  <ProtocolVersion Value="1" />
  <ApplicationContextName Value="LN" />
  <AssociationResult Value="01" />
  <ResultSourceDiagnostic>
    <ACSEServiceUser Value="0B" />
  </ResultSourceDiagnostic>
</AssociationResponse>

Autre cas : 6128A109060760857405080101A203020101A305A103020101890760857405080202BE0604040E010604
<AssociationResponse>
  <ApplicationContextName Value="LN" />
  <AssociationResult Value="01" />
  <ResultSourceDiagnostic>
    <ACSEServiceUser Value="01" />
  </ResultSourceDiagnostic>
  <MechanismName Value="HIGH_SECURITY" />
  <ConfirmedServiceError>
    <Service Value="01" />
    <ServiceError>
      <Initiate Value="RefusedByTheVDEHandler" />
    </ServiceError>
  </ConfirmedServiceError>
</AssociationResponse>




*/


/*

61 4F

  A109060760857405080101
  A203020100
  A305A10302010E
  A40A0408414243444546474

  888020780
  890760857405080205

  AA0A8008503677524A323146

  BE11
  040F
      08  ==> initiate response

      01 00  ==> QoS = true

      06 5F1F040000021D04000007

-----------------------------------------------------------------
 6142
   A109060760857405080101
   A203020100
   A305A103020100

ACSE Req
   88 02 0780
Mechanism-name
   8907 60857405080201

   Responding authentication value
   AA0A80084142434445464748

   BE10040E0800065F1F040000101D21340007

-------------------------------------

  6182003A

  80020780

  A109060760857405080101
  A203020100
  A305A103020100

  88020780
  890760857405080201

  BE10040E0800065F1F040000301D21340007

 **/

void ACSEDecoder(const char *frame, int sz, csm_asso_tag tag)
{
    csm_asso_state state;
    csm_array array;

    csm_sys_init();

    state.auth_level = CSM_AUTH_LOW_LEVEL;
    state.ref = LN_REF;


    // transform the hexadecimal string into an array of integers
    size_t packet_size = sz/2U;
    uint8_t *packet = (uint8_t *) malloc(packet_size);

    if (packet != NULL)
    {
        uint8_t *packet_ptr = packet;

        hex2bin(frame, (char *)packet, sz);
       // print_hex((const char*)&packet[0], packet_size);

        csm_array_init(&array, &packet[0], packet_size, packet_size, 0U);

        int ret = csm_asso_decoder(&state, &array, tag);
        REQUIRE(ret == TRUE);

        if (tag == CSM_ASSO_AARQ)
        {
            puts("CtoS\r\n");
            print_hex((const char*)&state.handshake.ctos.value[0], state.handshake.ctos.size);
        }
        else
        {
            puts("StoC\r\n");
            print_hex((const char*)&state.handshake.stoc.value[0], state.handshake.stoc.size);
        }
    }
}

void AAREDecoder(const char *frame, int sz)
{
    ACSEDecoder(frame, sz, CSM_ASSO_AARE);
}

void AARQDecoder(const char *frame, int sz)
{
    ACSEDecoder(frame, sz, CSM_ASSO_AARQ);
}


void TestVectorHLS3()
{

    // TEST Vector Cyx
    static const char HLSSecret[] = "000102030405060708090A0B0C0D0E0F";

    static const char md5CtoS[] = "0C0F910048247310C0F2B79770BADA38F6CAA6B27D2654CF8BD2B43888B0AFCF";
    static const char md5StoC[] = "B1582C160B8542A1D068349A4DA65329944A25120984C261B0D86CB6DBED763B";

    static const uint32_t SizeOfChallenge = strlen(md5StoC);

    static const char md5ExpectedPass3Hash[] = "41C845AEEA55D9C9CDE708AF0BA5B4BD";
    static const char md5ExpectedPass4Hash[] = "3B5BCE648F4AFAE9F5EEF44E9BEE9CCD";

    uint8_t *secret = HexToBin(HLSSecret, 32U);
    uint8_t *stoc = HexToBin(md5StoC, SizeOfChallenge);
    uint8_t *expected = HexToBin(md5ExpectedPass3Hash, 32U);

    uint8_t digest_input[1024];
    uint8_t digest[16];

    // MD5(StoC || HLS Secret)
    memcpy(&digest_input[0], stoc, SizeOfChallenge/2);
    memcpy(&digest_input[SizeOfChallenge/2], secret, 16U);

    uint32_t sizeOfDigestInput = 16U + (SizeOfChallenge/2);
    csm_hal_md5(digest_input, sizeOfDigestInput, digest);

    print_hex((const char*)&digest_input[0], sizeOfDigestInput);

    for (uint32_t i = 0; i < 16U; i++)
    {
        if (expected[i] != digest[i])
        {
            std::cout << "MD5 digest Different at: " << i << std::endl;
        }
        REQUIRE(expected[i] == digest[i]);
    }

}


void TestVectorHLS2Saphir()
{
    // TEST vector Saphir Enerdis
    static const char HLSSecret[] = "F50AB847E31D96C2A5F6B3E901E24A18";
    static const uint32_t SizeOfSecret = 32U;
    static const char StoC[] = "0B2EF7388ACE48BB9A2B4866047058594E3004F6F31AED93A08740138E7F1C98AD15CF38E210EA7D3A34";
    static const uint32_t SizeOfChallenge = strlen(StoC);
    static const char ExpectedPass3Hash[] = "82D0DBCBA291ED0954E2BD14B3DEC09F73A12906E1EF7DF36D16F008FDDD74BC";
    static const uint32_t SizeOfInputHash = 64U;

    uint8_t *secret = HexToBin(HLSSecret, 32U);
    uint8_t *stoc = HexToBin(StoC, SizeOfChallenge);
    uint8_t *expected = HexToBin(ExpectedPass3Hash, SizeOfInputHash);

    uint8_t digest_input[1024];
    uint8_t digest[SizeOfInputHash / 2];

    // MD5(StoC || HLS Secret)
    memcpy(&digest_input[0], stoc, SizeOfChallenge/2);
    memcpy(&digest_input[SizeOfChallenge/2], secret, 16U);

    uint32_t sizeOfDigestInput = 16U + (SizeOfChallenge/2);
    csm_hal_sha256(digest_input, sizeOfDigestInput, digest);

    print_hex((const char*)&digest_input[0], sizeOfDigestInput);

    for (uint32_t i = 0; i < (SizeOfInputHash/2); i++)
    {
        if (expected[i] != digest[i])
        {
            std::cout << "HLS2 Saphir SHA256 digest Different at: " << i << std::endl;
        }
        REQUIRE(expected[i] == digest[i]);
    }

}

TEST_CASE( "AARQ", "[AARQ-Encoder]" )
{
    puts("\r\n--------------------------  COSEM AARQ 1  --------------------------\r\n");
    AARQEncoder();
}

TEST_CASE( "AARE1", "[AARE1-Decoder]" )
{
    puts("\r\n--------------------------  COSEM AARE 1  --------------------------\r\n");
    AAREDecoder(aare_no_auth_ok, sizeof(aare_no_auth_ok));
}

TEST_CASE( "AARE2", "[AARE2-Decoder]" )
{
    puts("\r\n--------------------------  COSEM AARE 2  --------------------------\r\n");
    AAREDecoder(aare_auth_ok_simple, sizeof(aare_auth_ok_simple));
}

TEST_CASE( "AARE3-HLS", "[AARE3-Decoder]" )
{
    puts("\r\n--------------------------  COSEM AARE 3  --------------------------\r\n");
    AAREDecoder(aare_hls_ok, sizeof(aare_hls_ok));
}

TEST_CASE( "AARE4-HLS", "[AARE4-Decoder]" )
{
    puts("\r\n--------------------------  COSEM AARE 4  --------------------------\r\n");
    AAREDecoder(aare_saphir_ko, sizeof(aare_saphir_ko));
}

TEST_CASE( "HLS3-MD5", "[HLS3-MD5-TestVector]" )
{
    puts("\r\n--------------------------  COSEM HLS3 (MD5)  --------------------------\r\n");
    TestVectorHLS3();
}

TEST_CASE( "HLS2-SHA256", "[HLS2-SHA256-TestVector]" )
{
    puts("\r\n--------------------------  COSEM HLS2 Saphir (SHA-256)  --------------------------\r\n");
    TestVectorHLS2Saphir();
}


TEST_CASE( "AARQ-Saphir-Decoder", "[AARQ-Decoder]" )
{
    puts("\r\n--------------------------  COSEM AARQ Saphir Decoder 1  --------------------------\r\n");
    AARQDecoder(aarq_saphir_enerdis, sizeof(aarq_saphir_enerdis));
}

TEST_CASE( "AARE-Saphir-Decoder", "[AARQ-Decoder]" )
{
    puts("\r\n--------------------------  COSEM AARE Saphir Decoder 1  --------------------------\r\n");
    AAREDecoder(aare_saphir_enerdis, sizeof(aare_saphir_enerdis));
}
